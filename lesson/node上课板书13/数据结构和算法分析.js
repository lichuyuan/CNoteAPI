// 时间、空间复杂度(空间复杂度一般不考虑)
// 复杂度是对一个操作的大致估计
// 复杂度从小到大依次如下
/*
五种常见时间复杂度
复杂度用 大 O 记法 来描述(大 O 记法是描述算法复杂度的符号)
说的是算法的上界, 不一定是最坏情况


O(1)
    常数复杂度, 最快速的算法。
    取数组第 1000000 个元素
    字典和集合的存取都是 O(1)
    数组的存取是 O(1)
O(lgN)
    对数复杂度
    假设有一个有序数组, 以二分法查找
    2^n = 1000 -> n = lg1000 -> n = 10
O(n)
    线性复杂度
    假设有一个数组, 以遍历的方式在其中查找元素
O(nlgn)
    求两个数组交集, 其中 A 是无序数组, B 是有序数组
    A 有 M 个元素, B 有 N 个元素
    A 数组每一个元素都要在 B 数组中进行查找操作
    每次查找如果使用二分法则复杂度是 O(lgN)
    查找 M 次即是 O(M)
    总的就是 O(M) * O(lgN) = O(MlgN)
O(N²)
    平方复杂度
    求两个无序数组的交集, 其中 A 是无序数组, B 是无序数组
    A 有 M 个元素, B 有 N 个元素
    A 数组每一个元素都要在 B 数组中进行查找操作
    每次查找复杂度是 O(N)
    查找 M 次即是 O(M)
    总的就是 O(M) * O(N) = O(MN)
*/


/*
数据结构
===

针对常用的操作, 我们发明了一套常用的数据结构
四大数据结构
1, 数组
    连续的一块内存
    读取元素时间是 O(1)
    插入、删除是 O(n)
    123456789

    12345 789
    123457 89
    1234578 9
    12345789

    1234578 9
    123457 89
    12345 789
    1234 5789
    123405789

2, 链表
    手拉手的盒子, 一个盒子只能访问左右手的盒子
    以下标方式读取元素的时间是 O(n)
    插入、删除是 O(1)
    栈和队列是链表的特定场景应用(当然, 不用链表也能实现栈和队列)
3, 字典 hash table
    o = {
        'name': 'gua',
    }
    把字符串转为数字作为下标存储到数组中
    字符串转化为数字的算法是 O(1)
    所以字典的存取操作都是 O(1)
    除非对数据有顺序要求, 否则字典永远是最佳选择
    字符串转化为数字的算法
        1, 确定数据规模, 这样可以确定容器数组的大小 Size
        2, 把字符当作 N 进制数字得到结果
            'gua' 被视为 g * 1 + u * 10 + a * 100 得到结果 n
            n % Size 作为字符串在数组中的下标
            通常 Size 会选一个 素数
4, 搜索树（我们只用, 不写, 甚至只是隐含在用, 你并不知道你用的是树）
    AVL 树, 名字是三个作者的缩写
    红黑树, 非常难

额外的, 图是一种有时候有用但你一辈子都可能写不到的数据结构
只了解, 不用学习如何实现
图的应用举例
    地图导航
    全国几个大城市之间的出行方案(有价格/时间/路途等权重)
*/
